<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AddModelButtonText" xml:space="preserve">
    <value>Add Model</value>
  </data>
  <data name="AllowOverwriteDescription" xml:space="preserve">
    <value>If unchecked, upscaling will be skipped for videos that already exist in the output path. If checked, any videos that already exist in the output path will be overwritten without warning. Use with caution.</value>
  </data>
  <data name="AllowOverwriteLabel" xml:space="preserve">
    <value>Allow Videos in Output Path to be Overwritten</value>
  </data>
  <data name="AppNotInstalledText" xml:space="preserve">
    <value>App is not installed; auto update settings unavailable.</value>
  </data>
  <data name="AppSettingsButtonText" xml:space="preserve">
    <value>設定</value>
  </data>
  <data name="AppSettingsHeader" xml:space="preserve">
    <value>設定</value>
  </data>
  <data name="AutoUpdateDescription" xml:space="preserve">
    <value>Whether to automatically check for and install app updates.</value>
  </data>
  <data name="AutoUpdateLabel" xml:space="preserve">
    <value>自動更新</value>
  </data>
  <data name="BatchVideoUpscaleTabHeader" xml:space="preserve">
    <value>Batch Video Upscale</value>
  </data>
  <data name="CancelButtonText" xml:space="preserve">
    <value>Cancel</value>
  </data>
  <data name="CheckForUpdatesNowButtonText" xml:space="preserve">
    <value>更新を確認する</value>
  </data>
  <data name="ConsoleButtonText" xml:space="preserve">
    <value>コンソール</value>
  </data>
  <data name="CurrentVersionLabel" xml:space="preserve">
    <value>Current Version</value>
  </data>
  <data name="DownloadUpdateButtonText" xml:space="preserve">
    <value>更新をダウンロードする</value>
  </data>
  <data name="EnableInterpolationDescription" xml:space="preserve">
    <value>Whether or not to run video frame interpolation.</value>
  </data>
  <data name="EnableInterpolationLabel" xml:space="preserve">
    <value>Enable Interpolation</value>
  </data>
  <data name="EnsembleDescription" xml:space="preserve">
    <value>Whether or not to use the ensemble version of the model, which improves quality but runs slower.</value>
  </data>
  <data name="EnsembleLabel" xml:space="preserve">
    <value>Ensemble</value>
  </data>
  <data name="ExportWorkflowButtonText" xml:space="preserve">
    <value>Export Workflow</value>
  </data>
  <data name="FfmpegOutputSettingsDescription" xml:space="preserve">
    <value>Video encoding settings to pass to FFmpeg. Choose a preset below or edit the text to use custom settings.</value>
  </data>
  <data name="FfmpegOutputSettingsLabel" xml:space="preserve">
    <value>FFmpeg Output Video Settings</value>
  </data>
  <data name="FfmpegPresetsDescriptionLossless" xml:space="preserve">
    <value>FFV1 lossless compression, usually fastest to encode but extremely large filesize, and may be slower if bottlenecked by a slow storage drive.</value>
  </data>
  <data name="FfmpegPresetsDescriptionNvencHevc" xml:space="preserve">
    <value>HEVC compression with NVENC, fast encode using GPU but lower quality than CPU encoding.</value>
  </data>
  <data name="FfmpegPresetsDescriptionX264" xml:space="preserve">
    <value>x264 compression, OK compression, faster to encode.</value>
  </data>
  <data name="FfmpegPresetsDescriptionX265" xml:space="preserve">
    <value>x265 compression, more efficient compression but slower to encode.</value>
  </data>
  <data name="FfmpegPresetsLabel" xml:space="preserve">
    <value>FFmpeg Presets</value>
  </data>
  <data name="FinalResizeFactorDescription" xml:space="preserve">
    <value>Resize the video by this factor after running all models. The video width and height are scaled by this percentage, so a value of 100% performs no resize, and a value of 50% cuts the width and height of the video in half. This setting is ignored if Final Resize Height is specified. Note that the final video width and height must be divisble by 2 or the output video will be invalid.</value>
  </data>
  <data name="FinalResizeFactorLabel" xml:space="preserve">
    <value>Final Resize Factor</value>
  </data>
  <data name="FinalResizeHeightDescription" xml:space="preserve">
    <value>Resize the video to this height after running all models, set to 0 to disable. Note that the final video width and height must be divisble by 2 or the output video will be invalid.</value>
  </data>
  <data name="FinalResizeHeightLabel" xml:space="preserve">
    <value>Final Resize Height</value>
  </data>
  <data name="FirstTimeSetupText" xml:space="preserve">
    <value>Performing first time setup. This may take several minutes...</value>
  </data>
  <data name="ImportWorkflowButtonText" xml:space="preserve">
    <value>Import Workflow</value>
  </data>
  <data name="InputFolderDescription" xml:space="preserve">
    <value>Path of the folder to upscale. The folder will be scanned and all video files (*.mkv, *.mp4, *.mpg, *.mpeg, *.avi, *.mov, *.wmv) found will be upscaled.</value>
  </data>
  <data name="InputFolderLabel" xml:space="preserve">
    <value>Input Folder</value>
  </data>
  <data name="InputVideoDescription" xml:space="preserve">
    <value>Path of the video file to upscale.</value>
  </data>
  <data name="InputVideoLabel" xml:space="preserve">
    <value>Input Video</value>
  </data>
  <data name="InterpolationFactorDescription" xml:space="preserve">
    <value>Interpolation factor represented as a fraction. For example, 2 / 1 will double the framerate.</value>
  </data>
  <data name="InterpolationFactorLabel" xml:space="preserve">
    <value>Interpolation Factor</value>
  </data>
  <data name="InterpolationModelDescription" xml:space="preserve">
    <value>Interpolation model to run. Higher RIFE version is newer and usually better quality.</value>
  </data>
  <data name="InterpolationModelLabel" xml:space="preserve">
    <value>Model</value>
  </data>
  <data name="InterpolationSettingsHeader" xml:space="preserve">
    <value>Interpolation Settings</value>
  </data>
  <data name="ModelHeader" xml:space="preserve">
    <value>Model</value>
  </data>
  <data name="MoreUpscaleSettingsLabel" xml:space="preserve">
    <value>Show More Upscale Settings</value>
  </data>
  <data name="OnnxModelPathDescription" xml:space="preserve">
    <value>File path of the ONNX model to run.</value>
  </data>
  <data name="OnnxModelPathLabel" xml:space="preserve">
    <value>ONNX Model Path</value>
  </data>
  <data name="OutputFilenameDescription" xml:space="preserve">
    <value>The filename of the upscaled video, including the desired file extension. %filename% is the input filename without extension.</value>
  </data>
  <data name="OutputFilenameLabel" xml:space="preserve">
    <value>Output Filename</value>
  </data>
  <data name="OutputFolderDescription" xml:space="preserve">
    <value>Path of the folder to save the upscaled video files.</value>
  </data>
  <data name="OutputFolderLabel" xml:space="preserve">
    <value>Output Folder</value>
  </data>
  <data name="RemoveModelButtonText" xml:space="preserve">
    <value>Remove Model</value>
  </data>
  <data name="ResetWorkflowButtonText" xml:space="preserve">
    <value>Reset Workflow</value>
  </data>
  <data name="ResizeFactorBeforeUpscaleDescription" xml:space="preserve">
    <value>Resize the video by this factor before running this model. The video width and height are scaled by this percentage, so a value of 100% performs no resize, and a value of 50% cuts the width and height of the video in half. This setting is ignored if Resize Height Before Upscale is specified.</value>
  </data>
  <data name="ResizeFactorBeforeUpscaleLabel" xml:space="preserve">
    <value>Resize Factor Before Upscale</value>
  </data>
  <data name="ResizeHeightBeforeUpscaleDescription" xml:space="preserve">
    <value>Resize the video to this height before running this model, set to 0 to disable.</value>
  </data>
  <data name="ResizeHeightBeforeUpscaleLabel" xml:space="preserve">
    <value>Resize Height Before Upscale</value>
  </data>
  <data name="RestartToUpdateButtonText" xml:space="preserve">
    <value>Restart to Update VideoJaNai</value>
  </data>
  <data name="ReturnButtonText" xml:space="preserve">
    <value>戻る</value>
  </data>
  <data name="SceneDetectionThresholdDescription" xml:space="preserve">
    <value>Scene detection is used to prevent interpolating frames during hard transitions between scenes. The threshold adjusts the sensitivity for what is considered a scene change. If the threshold is too high, more interpolation artifacts may be visible during scene transitions. If the threshold is too low, the video may stutter more.</value>
  </data>
  <data name="SceneDetectionThresholdLabel" xml:space="preserve">
    <value>Scene Detection Threshold</value>
  </data>
  <data name="SelectFileButtonText" xml:space="preserve">
    <value>ファイルを選択する</value>
  </data>
  <data name="SelectFolderButtonText" xml:space="preserve">
    <value>フォルダーを選択する</value>
  </data>
  <data name="SingleVideoUpscaleTabHeader" xml:space="preserve">
    <value>Single Video Upscale</value>
  </data>
  <data name="UpscaleButtonText" xml:space="preserve">
    <value>Upscale</value>
  </data>
  <data name="UpscaleSettingsHeader" xml:space="preserve">
    <value>Upscale Settings</value>
  </data>
  <data name="UpscalingBackendDescriptionDirectMl" xml:space="preserve">
    <value>Compatible with NVIDIA, AMD, and Intel GPUs but slower than TensorRT. Supports fp32 ONNX models only.</value>
  </data>
  <data name="UpscalingBackendDescriptionNcnn" xml:space="preserve">
    <value>Compatible with NVIDIA, AMD, and Intel GPUs but typically slower than DirectML. Supports fp32 ONNX models only.</value>
  </data>
  <data name="UpscalingBackendDescriptionTensorRt" xml:space="preserve">
    <value>Fastest option but NVIDIA only. Supports fp16 and fp32 ONNX models. fp16 models are recommended for faster performance and reduced VRAM usage without any loss in quality. The initial engine generation may require several minutes but only needs to be done once.</value>
  </data>
  <data name="UpscalingBackendLabel" xml:space="preserve">
    <value>Upscaling Backend</value>
  </data>
  <data name="VideoInputAndOutputHeader" xml:space="preserve">
    <value>Video Input and Output</value>
  </data>
  <data name="WorkflowNameLabel" xml:space="preserve">
    <value>Workflow Name</value>
  </data>
  <data name="WorkflowsLabel" xml:space="preserve">
    <value>Workflows</value>
  </data>
  <data name="WorkflowsTooltip" xml:space="preserve">
    <value>Workflows provide convenient access to save and load preset settings for upscaling.</value>
  </data>
</root>